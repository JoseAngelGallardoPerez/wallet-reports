<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: users.proto

namespace Velmie\Wallet\Users;

use Google\Protobuf\Internal\GPBDecodeException;
use Http\Message\MessageFactory;
use Http\Message\StreamFactory;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Twirp\BaseServerHooks;
use Twirp\Context;
use Twirp\ErrorCode;
use Twirp\RequestHandler;
use Twirp\ServerHook;

/**
 * @see UserHandler
 *
 * Generated from protobuf service <code>velmie.wallet.users.UserHandler</code>
 */
final class UserHandlerServer implements RequestHandler
{
    const PATH_PREFIX = '/twirp/velmie.wallet.users.UserHandler/';

    /**
     * @var UserHandler
     */
    private $svc;

    /**
     * @var ServerHook
     */
    private $hook;

    /**
     * @param UserHandler $svc
     * @param ServerHooks|null    $hook
     * @param MessageFactory|null $messageFactory
     * @param StreamFactory|null  $streamFactory
     */
    public function __construct(
        UserHandler $svc,
        ServerHook $hook = null,
        MessageFactory $messageFactory = null,
        StreamFactory $streamFactory = null
    ) {
        parent::__construct($messageFactory, $streamFactory);

        if ($hook === null) {
            $hook = new BaseServerHooks();
        }

        $this->svc = $svc;
        $this->hook = $hook;
    }

    /**
     * Handle the request and return a response.
     *
     * @param ServerRequestInterface $req
     *
     * @return ResponseInterface
     */
    public function handle(ServerRequestInterface $req)
    {
        $ctx = $req->getAttributes();
        $ctx = Context::withPackageName($ctx, 'velmie.wallet.users');
        $ctx = Context::withServiceName($ctx, 'UserHandler');

        try {
            $ctx = $this->hook->requestReceived($ctx);
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        if ($req->getMethod() !== 'POST') {
            $msg = sprintf('unsupported method "%s" (only POST is allowed)', $req->getMethod());

            return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }

        switch ($req->getUri()->getPath()) {
            case '/twirp/velmie.wallet.users.UserHandler/GetByUID':
                return $this->handleGetByUID($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetByUsername':
                return $this->handleGetByUsername($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetByProfileData':
                return $this->handleGetByProfileData($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetByRoleName':
                return $this->handleGetByRoleName($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/ValidateAccessToken':
                return $this->handleValidateAccessToken($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetByUIDs':
                return $this->handleGetByUIDs($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetByUserGroupId':
                return $this->handleGetByUserGroupId($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetAll':
                return $this->handleGetAll($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetFullUsersByUIDs':
                return $this->handleGetFullUsersByUIDs($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetDevicesByUID':
                return $this->handleGetDevicesByUID($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetByAdministratorClassId':
                return $this->handleGetByAdministratorClassId($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/ValidateTmpAuthToken':
                return $this->handleValidateTmpAuthToken($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetStaffUsers':
                return $this->handleGetStaffUsers($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetCompaniesByIDs':
                return $this->handleGetCompaniesByIDs($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/SaveCompaniesByName':
                return $this->handleSaveCompaniesByName($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/UpdateUserAndAttributes':
                return $this->handleUpdateUserAndAttributes($ctx, $req);
            case '/twirp/velmie.wallet.users.UserHandler/GetUserAndAttributes':
                return $this->handleGetUserAndAttributes($ctx, $req);

            default:
                return $this->writeError($ctx, $this->noRouteError($req));
        }
    }

    private function handleGetByUID(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByUIDJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByUIDProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByUIDJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUID');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByUID($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUID. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByUIDProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUID');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByUID($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUID. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetByUsername(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByUsernameJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByUsernameProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByUsernameJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUsername');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByUsername($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUsername. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByUsernameProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUsername');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByUsername($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUsername. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetByProfileData(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByProfileDataJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByProfileDataProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByProfileDataJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByProfileData');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByProfileData($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByProfileData. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByProfileDataProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByProfileData');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByProfileData($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByProfileData. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetByRoleName(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByRoleNameJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByRoleNameProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByRoleNameJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByRoleName');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByRoleName($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByRoleName. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByRoleNameProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByRoleName');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByRoleName($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByRoleName. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleValidateAccessToken(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleValidateAccessTokenJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleValidateAccessTokenProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleValidateAccessTokenJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'ValidateAccessToken');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->ValidateAccessToken($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling ValidateAccessToken. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleValidateAccessTokenProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'ValidateAccessToken');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->ValidateAccessToken($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling ValidateAccessToken. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetByUIDs(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByUIDsJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByUIDsProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByUIDsJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUIDs');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByUIDs($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUIDs. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByUIDsProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUIDs');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByUIDs($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUIDs. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetByUserGroupId(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByUserGroupIdJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByUserGroupIdProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByUserGroupIdJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUserGroupId');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByUserGroupId($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUserGroupId. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByUserGroupIdProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByUserGroupId');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByUserGroupId($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByUserGroupId. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetAll(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetAllJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetAllProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetAllJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetAll');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetAll($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetAll. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetAllProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetAll');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetAll($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetAll. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetFullUsersByUIDs(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetFullUsersByUIDsJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetFullUsersByUIDsProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetFullUsersByUIDsJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetFullUsersByUIDs');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\RequestFullUsersByUIDs();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetFullUsersByUIDs($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetFullUsersByUIDs. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetFullUsersByUIDsProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetFullUsersByUIDs');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\RequestFullUsersByUIDs();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetFullUsersByUIDs($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetFullUsersByUIDs. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetDevicesByUID(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetDevicesByUIDJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetDevicesByUIDProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetDevicesByUIDJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetDevicesByUID');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\DevicesRequest();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetDevicesByUID($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetDevicesByUID. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetDevicesByUIDProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetDevicesByUID');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\DevicesRequest();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetDevicesByUID($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetDevicesByUID. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetByAdministratorClassId(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetByAdministratorClassIdJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetByAdministratorClassIdProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetByAdministratorClassIdJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByAdministratorClassId');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetByAdministratorClassId($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByAdministratorClassId. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetByAdministratorClassIdProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetByAdministratorClassId');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetByAdministratorClassId($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetByAdministratorClassId. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleValidateTmpAuthToken(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleValidateTmpAuthTokenJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleValidateTmpAuthTokenProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleValidateTmpAuthTokenJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'ValidateTmpAuthToken');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->ValidateTmpAuthToken($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling ValidateTmpAuthToken. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleValidateTmpAuthTokenProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'ValidateTmpAuthToken');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->ValidateTmpAuthToken($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling ValidateTmpAuthToken. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetStaffUsers(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetStaffUsersJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetStaffUsersProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetStaffUsersJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetStaffUsers');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetStaffUsers($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetStaffUsers. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetStaffUsersProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetStaffUsers');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\Request();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetStaffUsers($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetStaffUsers. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetCompaniesByIDs(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetCompaniesByIDsJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetCompaniesByIDsProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetCompaniesByIDsJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetCompaniesByIDs');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\CompaniesIDsRequest();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetCompaniesByIDs($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetCompaniesByIDs. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetCompaniesByIDsProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetCompaniesByIDs');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\CompaniesIDsRequest();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetCompaniesByIDs($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetCompaniesByIDs. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleSaveCompaniesByName(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleSaveCompaniesByNameJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleSaveCompaniesByNameProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleSaveCompaniesByNameJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'SaveCompaniesByName');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\CompaniesNameRequest();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->SaveCompaniesByName($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling SaveCompaniesByName. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleSaveCompaniesByNameProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'SaveCompaniesByName');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\CompaniesNameRequest();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->SaveCompaniesByName($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling SaveCompaniesByName. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleUpdateUserAndAttributes(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleUpdateUserAndAttributesJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleUpdateUserAndAttributesProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleUpdateUserAndAttributesJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'UpdateUserAndAttributes');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\UserUpdateRequest();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->UpdateUserAndAttributes($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling UpdateUserAndAttributes. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleUpdateUserAndAttributesProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'UpdateUserAndAttributes');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\UserUpdateRequest();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->UpdateUserAndAttributes($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling UpdateUserAndAttributes. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }
    private function handleGetUserAndAttributes(array $ctx, ServerRequestInterface $req)
    {
        $header = $req->getHeaderLine('Content-Type');
        $i = strpos($header, ';');

        if ($i === false) {
            $i = strlen($header);
        }

        switch (trim(strtolower(substr($header, 0, $i)))) {
            case 'application/json':
                return $this->handleGetUserAndAttributesJson($ctx, $req);

            case 'application/protobuf':
                return $this->handleGetUserAndAttributesProtobuf($ctx, $req);

            default:
                $msg = sprintf('unexpected Content-Type: "%s"', $req->getHeaderLine('Content-Type'));

                return $this->writeError($ctx, $this->badRoute($msg, $req->getMethod(), $req->getUri()->getPath()));
        }
    }

    private function handleGetUserAndAttributesJson(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetUserAndAttributes');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\UserGetRequest();
            $in->mergeFromJsonString((string)$req->getBody());

            $out = $this->svc->GetUserAndAttributes($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetUserAndAttributes. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request json'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToJsonString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/json')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    private function handleGetUserAndAttributesProtobuf(array $ctx, ServerRequestInterface $req)
    {
        $ctx = Context::withMethodName($ctx, 'GetUserAndAttributes');

        try {
            $ctx = $this->hook->requestRouted($ctx);

            $in = new \Velmie\Wallet\Users\UserGetRequest();
            $in->mergeFromString((string)$req->getBody());

            $out = $this->svc->GetUserAndAttributes($ctx, $in);

            if ($out === null) {
                return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'received a null response while calling GetUserAndAttributes. null responses are not supported'));
            }

            $ctx = $this->hook->responsePrepared($ctx);
        } catch (GPBDecodeException $e) {
            return $this->writeError($ctx, TwirpError::newError(ErrorCode::Internal, 'failed to parse request proto'));
        } catch (\Twirp\Error $e) {
            return $this->writeError($ctx, $e);
        } catch (\Twirp\Exception $e) {
            return $this->writeError($ctx, $e->getError());
        } catch (\Exception $e) {
            return $this->writeError($ctx, TwirpError::errorFromException($e));
        }

        $data = $out->serializeToString();

        $body = $this->streamFactory->createStream($data);

        $resp = $this->messageFactory
            ->createResponse(200)
            ->withHeader('Content-Type', 'application/protobuf')
            ->withBody($body);

        $this->callResponseSent($ctx);

        return $resp;
    }

    /**
     * Writes Twirp errors in the response and triggers hooks.
     *
     * @param array        $ctx
     * @param \Twirp\Error $e
     *
     * @return ResponseInterface
     */
    protected function writeError(array $ctx, \Twirp\Error $e)
    {
        $statusCode = ErrorCode::serverHTTPStatusFromErrorCode($e->code());
        $ctx = Context::withStatusCode($ctx, $statusCode);

        try {
            $ctx = $this->hook->error($ctx, $e);
        } catch (\Exception $e) {
            // We have three options here. We could log the error, call the Error
            // hook, or just silently ignore the error.
            //
            // Logging is unacceptable because we don't have a user-controlled
            // logger; writing out to stderr without permission is too rude.
            //
            // Calling the Error hook would confuse users: it would mean the Error
            // hook got called twice for one request, which is likely to lead to
            // duplicated log messages and metrics, no matter how well we document
            // the behavior.
            //
            // Silently ignoring the error is our least-bad option. It's highly
            // likely that the connection is broken and the original 'err' says
            // so anyway.
        }

        $this->callResponseSent($ctx);

        return parent::writeError($ctx, $e);
    }

    /**
     * Triggers response sent hook.
     *
     * @param array $ctx
     */
    private function callResponseSent(array $ctx)
    {
        try {
            $this->hook->responseSent($ctx);
        } catch (\Exception $e) {
            // We have three options here. We could log the error, call the Error
            // hook, or just silently ignore the error.
            //
            // Logging is unacceptable because we don't have a user-controlled
            // logger; writing out to stderr without permission is too rude.
            //
            // Calling the Error hook could confuse users: this hook is triggered
            // by the error hook itself, which is likely to lead to
            // duplicated log messages and metrics, no matter how well we document
            // the behavior.
            //
            // Silently ignoring the error is our least-bad option. It's highly
            // likely that the connection is broken and the original 'err' says
            // so anyway.
        }
    }
}
